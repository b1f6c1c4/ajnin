/* Copyright (C) 2021 b1f6c1c4
 *
 * This file is part of ajnin.
 *
 * ajnin is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, version 3.
 *
 * ajnin is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
 * more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ajnin.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "manager.hpp"

#include <filesystem>
#include <iostream>
#include "TLexer.h"

using namespace parsing;
using namespace std::string_literals;

manager::manager(bool debug, bool quiet, size_t limit) : _debug{ debug }, _debug_limit{ limit }, _quiet{ quiet } { }

antlrcpp::Any manager::visitMain(TParser::MainContext *ctx) {
    ctx_guard next{ _current };
    visitChildren(ctx);
    return {};
}

antlrcpp::Any manager::visitProlog(TParser::PrologContext *ctx) {
    auto s0 = ctx->LiteralNL()->getText();
    if (!s0.ends_with('\n')) throw std::runtime_error{ "Lexer messed up with \\n" };
    s0.pop_back();

    _prolog.emplace_back(expand_env(s0));
    return {};
}

antlrcpp::Any manager::visitEpilog(TParser::EpilogContext *ctx) {
    auto s0 = ctx->LiteralNL()->getText();
    if (!s0.ends_with('\n')) throw std::runtime_error{ "Lexer messed up with \\n" };
    s0.pop_back();

    _epilog.emplace_back(expand_env(s0));
    return {};
}

antlrcpp::Any manager::visitFileStmt(TParser::FileStmtContext *ctx) {
    auto s0 = ctx->Path()->getText();
    if (!s0.ends_with('\n')) throw std::runtime_error{ "Lexer messed up with \\n" };
    s0.pop_back();

    auto [s, flag] = expand(s0);
    if (flag) throw std::runtime_error{ "Glob not allowed in " + s0 };

    load_file(s);

    return {};
}

void manager::parse(antlr4::CharStream &is) {
    using namespace antlr4;
    TLexer lexer{ &is };
    CommonTokenStream tokens{ &lexer };
    tokens.fill();
    TParser parser{ &tokens };
    auto res = parser.main();
    if (parser.getNumberOfSyntaxErrors())
        throw std::runtime_error{ "Syntax error detected." };
    res->accept(this);
}

void manager::load_stream(std::istream &is) {
    antlr4::ANTLRInputStream s{ is };
    ctx_guard next{ _current };
    _current->cwd = std::filesystem::current_path();
    parse(s);
}

void manager::load_file(const std::string &str) {
    antlr4::ANTLRFileStream s{};
    if (_debug)
        std::cerr << std::string(_depth * 2, ' ') << "ajnin: Loading file " << str << "\n";
    _ajnin_deps.insert(str);
    _depth++;
    s.loadFromFile(str);
    ctx_guard next{ _current };
    _current->cwd = str;
    _current->cwd = _current->cwd->parent_path().lexically_normal();
    parse(s);
    _depth--;
}

static constexpr char g_ninja_prolog1[] = "# ajnin deps: ";
static constexpr char g_ninja_prolog2[] = "# No more ajnin deps.";

std::ostream &parsing::operator<<(std::ostream &os, manager &mgr) {
    if (!mgr._quiet)
        std::cerr << "ajnin: Emitting " << mgr._builds.size() << " builds\n";

    S max_deps_art;
    size_t max_deps{};
    for (auto &[art, pb] : mgr._builds) {
        pb->dedup();
        if (pb->deps.size() > max_deps) {
            max_deps_art = art;
            max_deps = pb->deps.size();
        }
    }
    if (!mgr._quiet)
        std::cerr << "ajnin: Largest fanin is " << max_deps << " deps (" << max_deps_art << ")\n";

    os << "# This file is automatically generated by ajnin. DO NOT MODIFY.\n";
    for (auto &d : mgr._ajnin_deps)
        os << g_ninja_prolog1 << d << "\n";
    os << g_ninja_prolog2 << "\n";

    for (auto &t : mgr._prolog)
        os << manager::expand_dollar(t) << '\n';

    for (auto &[art, pb] : mgr._builds) {
        os << "build " << manager::expand_dollar(art) << ": " << manager::expand_dollar(pb->rule);
        for (auto &dep : pb->deps)
            os << " " << manager::expand_dollar(dep);
        if (!pb->ideps.empty()) {
            os << " |";
            for (auto &dep : pb->ideps)
                os << " " << manager::expand_dollar(dep);
        }
        if (!pb->vars.empty()) {
            os << '\n';
            for (auto &[va, vl] : pb->vars)
                os << "    " << manager::expand_dollar(va) << " = " << manager::expand_dollar(vl) << '\n';
        }
        os << '\n';
    }

    for (auto &t : mgr._epilog)
        os << manager::expand_dollar(t) << '\n';

    return os;
}

bool manager::collect_deps(const S &fn, bool debug) {
    Ss deps;

    {
        std::ifstream ifs{ fn };
        if (!ifs.good()) {
            if (debug)
                std::cerr << "ajnin: Notice: Output file does not exist\n";
            return false;
        }
        while (!ifs.eof()) {
            S s;
            std::getline(ifs, s);
            if (!ifs.good()) {
                std::cerr << "ajnin: Warning: Cannot parse output file\n";
                return false;
            }
            if (!s.starts_with('#')) {
                std::cerr << "ajnin: Warning: Output file does not have deps info\n";
                return false;
            }
            if (s.starts_with(g_ninja_prolog2)) break;
            if (s.starts_with(g_ninja_prolog1))
                deps.emplace(s.substr(sizeof(g_ninja_prolog1) - 1));
        }
    }

    auto mt = std::filesystem::last_write_time(fn);

    auto good = true;
    for (auto &dep : deps) {
        std::filesystem::path p{ dep };
        if (!std::filesystem::exists(p)) {
            if (debug)
                std::cerr << "ajnin: Info: meta-dep " << dep << " does not exist.\n";
            good = false;
        } else if (std::filesystem::last_write_time(p) > mt) {
            if (debug)
                std::cerr << "ajnin: Info: meta-dep " << dep << " has been updated.\n";
            good = false;
        } else if (debug)
            std::cerr << "ajnin: Info: meta-dep " << dep << " is up-to-date.\n";
        if (!debug && !good) break;
    }

    return good;
}

antlrcpp::Any manager::visitMetaStmt(TParser::MetaStmtContext *ctx) {
    for (auto &s : ctx->stage()) {
        s->accept(this);
        _ajnin_deps.emplace(std::move(_current_artifact));
    }
    return {};
}
